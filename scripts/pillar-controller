#!/usr/bin/env ruby

require 'pillar'

Pillar.configure do |config|
end

WORKERS_KEY = '/workers'
service_threads = []
child_threads   = []

at_exit {
  print 'Cleaning up....'
  child_threads.each   {|t| t.kill}
  service_threads.each {|t| t.kill}
  puts 'done'
  exit!
}


def etcd
 Etcd.client( host: Pillar.configuration.etcd_hosts, port: 4001 )
end

def spawn_worker(worker)
  puts "Worker #{worker.inspect} type: #{worker.class}"
  begin
    worker.spawn
  rescue => e
    puts e.inspect
    puts caller
  end
  puts "Spawned worker"
end

def worker_by_path(worker_path)
  get_client  = etcd
  worker_json = get_client.get(worker_path).value
  worker      = Pillar::Serialization.from_json worker_json
end
def worker_by_id(worker_id)
  key = "#{WORKERS_KEY}/#{worker_id}"
  puts "Searching for key #{key}"
  worker_by_path(key)
end

def dispatch_worker(event)
  # Spawn new thread to handle new watch request
  Thread.new {

    case event.action
    when 'set'
      worker = worker_by_path(event.key)
      puts "Got new worker #{event.key} #{worker.inspect}"
      spawn_worker(worker)
      puts "Spawned worker #{event.key}"
    end

    puts "Processed Worker Event #{event.key}"
  } 
end



service_threads << Thread.new {
  listener = Listen.to(Pillar.configuration.pid_dir, only: /pillar\.\w+\.pid$/) do |modified, added, removed|
    puts "modified absolute path: #{modified}" unless modified.empty?
    puts "added absolute path: #{added}" unless added.empty?
    
    unless removed.empty?
      puts "removed absolute path: #{removed}" 
      path = removed.first
      worker_id = path.match(/pillar\.(\w+)\.pid$/)[1]
      if worker_id
        puts "Found WorkerID #{worker_id}"
        worker = worker_by_id(worker_id)
        puts "Got worker #{worker_id} info"
        spawn_worker(worker) if worker
        puts "Spawning worker #{worker_id}"
      end
    end

  end
  listener.start # not blocking
  puts "Watching pid path #{Pillar.configuration.pid_dir}"
  sleep
}



service_threads << Thread.new {
  watch_client = etcd

  puts "Watching Etcd Key #{Pillar.configuration.etcd_hosts}:4001/v2/keys/workers"
  loop do 
    etcd_event = watch_client.watch(WORKERS_KEY, recursive:true)

    puts "Found Worker Event #{etcd_event.key}"

    child_threads << dispatch_worker(etcd_event)   
  end
}


class SinatraController < Sinatra::Base

  get '/v1/' do
    {status: 'ok'}.to_json
  end

  get '/v1/host' do
    {host: Pillar::HOSTNAME}.to_json
  end

  post '/v1/workers/' do
    request.body.rewind
    payload = JSON.parse request.body.read

    # puts "Path:#{payload['args']}"
    worker = Pillar::Worker.new 'args' => payload['args'], 
                                'daemon' => payload['args'], 
                                'host' => Pillar::HOSTNAME
    puts "Worker: #{worker.inspect}"

    worker.to_json
  end
end

SinatraController.run!

# service_threads << Thread.new {SinatraController.run!}

# sleep

# child_threads.each   {|t| t.join}
# service_threads.each {|t| t.join}



